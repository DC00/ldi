__dyld_make_delayed_module_initializer_calls
__dyld_mod_term_funcs
impossible case in re_match
Str.string_match
Str.string_partial_match
Str.search_forward
Str.search_backward
Str.replace: illegal backslash sequence
Str.replace: reference to unmatched group
write
single_write
wait
waitpid
utimes
unlink
Unix.Unix_error
Exception Unix.Unix_error not initialized, please link unix.cma
truncate
tcsetattr
tcgetattr
tcsendbreak
tcdrain
tcflush
tcflow
symlink
string_of_inet_addr
stat
lstat
fstat
getsockopt
setsockopt
getsockopt_optint
setsockopt_optint
getsockopt_float
setsockopt_float
socketpair
socket
sigprocmask
sigpending
sigsuspend
shutdown
setuid
setgid
recv
recvfrom
send
sendto
select
rmdir
rewinddir
rename
readlink
readdir
read
putenv
pipe
opendir
open
nice
mkfifo
mkdir
lseek
lockf
listen
link
kill
setitimer
getitimer
gmtime
localtime
mktime
getsockname
gettimeofday
getpeername
getlogin
getgroups
getcwd
ftruncate
fork
set_nonblock
clear_nonblock
set_close_on_exec
clear_close_on_exec
fchown
fchmod
execvp
execve
execv
dup2
connect
closedir
close
chroot
chown
chmod
chdir
bind
inet_addr_of_string
access
accept
Sys.signal: unavailable signal
Growing gray_vals to %luk bytes
No room for growing gray_vals
Starting new major GC cycle
Marking %ld words
Sweeping %ld words
allocated_words = %lu
extra_heap_resources = %luu
amount of work to do = %luu
ordered work = %ld words
computed work = %ld words
Fatal error: not enough memory for the initial heap.
ref_table threshold crossed
Growing ref_table to %ldk bytes
Fatal error: ref_table overflow
Growing heap to %luk bytes
Growing page table to %lu entries
No room for growing page table
No room for growing heap
Shrinking heap to %luk bytes
Fatal error: out of memory.
Stack overflow in structural comparison
equal: abstract value
equal: functional value
int_of_string
format_int: format too long
input_value: native integer value too large
input_value: ill-formed native integer
float_of_string
String.create
Array.make
output_binary_int: not a binary channel
input_binary_int: not a binary channel
_chan
Marshal.to_buffer: buffer overflow
output_value: abstract value (Abstract)
output_value: abstract value (Custom)
output_value: functional value
output_value: abstract value (outside heap)
output_value: not a binary channel
input_value: integer too large
input_value: data block too large
input_value: code mismatch
input_value: unknown custom block identifier
input_value: ill-formed message
input_value: not a binary channel
input_value: bad object
input_value: truncated object
input_value_from_malloc: bad object
input_value_from_block: bad object
input_value_from_block: bad block length
Marshal.data_size: bad object
Unix
<unknown token>
State %d: read token %s
State %d: read token %s(
Recovering in state %d
Discarding state %d
No more states to discard
Discarding last token read
State %d: shift to state %d
State %d: reduce by rule %d
New space overhead: %d%%
New max overhead: %d%%
New heap increment size: %luk bytes
New minor heap size: %luk bytes
Estimated overhead (lower bound) = %lu%%
Automatic compaction triggered.
Major GC cycle requested
Full major GC cycle requested
Initial minor heap size: %luk bytes
Initial major heap size: %luk bytes
Initial space overhead: %lu%%
Initial max overhead: %lu%%
Initial heap increment: %luk bytes
Meta.static_release_bytecode impossible with native code
Obj.truncate
lexing: empty token
Pervasives.do_at_exit
Fatal error: exception %s
Weak.create
Weak.set
Weak.get
Compacting heap...
done.
FL size at phase change = %lu
Estimated overhead = %lu%%
Measured overhead: %lu%%
out of memory
Calling finalisation functions.
Done calling finalisation functions.
Gc.finalise
_final
PATH
dynamic loading not supported on this platform
=%u%c
=0x%x%c
OCAMLRUNPARAM
CAMLRUNPARAM
Out_of_memory
Sys_error
Failure
Invalid_argument
End_of_file
Division_by_zero
Not_found
Match_failure
Stack_overflow
Sys_blocked_io
Assert_failure
Undefined_recursive_module
*Pervasives0q
%Array0
$List0Z
$Char0
&String0
#Sys0
'Hashtbl0!
'Marshal0
#Obj0t~
%Int320+
%Int640M.
)Nativeint0
&Lexing0AS
'Parsing0p6
#Set0
#Map0
"\OEd
%Queue0
&Buffer0E
&Printf0
%Scanf0GU\d
#Arg0|
(Printexc0
&Digest0
&Random0
(Callback0
12vo
(Filename0
$Unix0
*UnixLabels0c
#Str0
$Util0G{
#Bug0
#Ast0
#Cfg0
(Dataflow0
&Parser0
%Lexer0
#~$&"
#Asm0yD
(Asmparse0
&Asmlex0
%Token0
'Unparse0
"Tc0B
%Opsem0
#Cpu0Tu
#Opt0
#Tac0
$Cgen0
$Main0o
(Std_exit0
1.36
.cl-asm
.cl-tac
.cl-type
.cl-type
.cl-type
.cl-type
.cl-ast
.cl3
aie!
.cl-lex
.cl2
cl-type
cl-tac
cl-lex
cl-ast
cl-asm
--lex
 stop after lexing (produce source.cl-lex file)
--unlex
 produce source.cl2 from lexed tokens
--parse
 stop after parsing (produce source.cl-ast file)
--unparse
 produce source.cl3 from abstract syntax tree
--type
 stop after type checking (produce source.cl-type file)
--class-map
 stop after type checking (produce source.cl-type class map file)
--imp-map
 stop after type checking (produce source.cl-type imp map file)
--parent-map
 stop after type checking (produce source.cl-type parent map file)
--tac
 stop and produce three address code (produce source.cl-tac file)
--asm
 stop and produce assembly output (produce source.cl-asm file)
--x86
 stop and produce x86-64 assembly output (produce source.s file)
--nocomm
 produce no assembly comments (handy for diffing)
--opt
 optimize generated assembly output
--cfg
 emit .dot (graphviz) format control flow graphs (req: --opt)
--trace-eval
 emit debugging information while evaluating
--profile
 produce performance profile of assembly evaluation
--out
X output to X.cl-whatever (instead of the default)
Cool Interpreter (version %s)
usage:
cool [options] source.{cl,cl-lex,cl-parse,cl-type,cl-tac,cl-asm}
Bool
Bool
.globl cooloutstr
.type
cooloutstr, @function
cooloutstr:
.LFB0:
.cfi_startproc
pushq
%rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq
%rsp, %rbp
.cfi_def_cfa_register 6
subq
$32, %rsp
movq
%rdi, -24(%rbp)
movl
$0, -4(%rbp)
.L5:
movl
-4(%rbp), %eax
cltq
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
cmpb
$92, %al
movl
-4(%rbp), %eax
cltq
addq
$1, %rax
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
cmpb
$110, %al
movq
stdout(%rip), %rax
movq
%rax, %rsi
movl
$10, %edi
call
fputc
addl
$2, -4(%rbp)
.L3:
movl
-4(%rbp), %eax
cltq
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
cmpb
$92, %al
movl
-4(%rbp), %eax
cltq
addq
$1, %rax
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
cmpb
$116, %al
movq
stdout(%rip), %rax
movq
%rax, %rsi
movl
$9, %edi
call
fputc
addl
$2, -4(%rbp)
.L4:
movq
stdout(%rip), %rdx
movl
-4(%rbp), %eax
cltq
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
movsbl
%al, %eax
movq
%rdx, %rsi
movl
%eax, %edi
call
fputc
addl
$1, -4(%rbp)
.L2:
movl
-4(%rbp), %eax
cltq
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
testb
%al, %al
movq
stdout(%rip), %rax
movq
%rax, %rdi
call
fflush
leave
.cfi_def_cfa 7, 8
.cfi_endproc
.LFE0:
.size
cooloutstr, .-cooloutstr
.globl coolstrlen
.type
coolstrlen, @function
coolstrlen:
.LFB1:
.cfi_startproc
pushq
%rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq
%rsp, %rbp
.cfi_def_cfa_register 6
movq
%rdi, -24(%rbp)
movl
$0, -4(%rbp)
.L8:
movl
-4(%rbp), %eax
addl
$1, %eax
movl
%eax, -4(%rbp)
.L7:
movl
-4(%rbp), %eax
%eax, %eax
addq
-24(%rbp), %rax
movzbl
(%rax), %eax
testb
%al, %al
movl
-4(%rbp), %eax
leave
.cfi_def_cfa 7, 8
.cfi_endproc
.LFE1:
.size
coolstrlen, .-coolstrlen
.section
.rodata
.LC0:
.string
"%s%s"
.text
.globl coolstrcat
.type
coolstrcat, @function
coolstrcat:
.LFB2:
.cfi_startproc
pushq
%rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq
%rsp, %rbp
.cfi_def_cfa_register 6
pushq
%rbx
subq
$40, %rsp
movq
%rdi, -40(%rbp)
movq
%rsi, -48(%rbp)
cmpq
$0, -40(%rbp)
.L10
.cfi_offset 3, -24
movq
-48(%rbp), %rax
.L11
.L10:
cmpq
$0, -48(%rbp)
.L12
movq
-40(%rbp), %rax
.L11
.L12:
movq
-40(%rbp), %rax
movq
%rax, %rdi
call
coolstrlen
movl
%eax, %ebx
movq
-48(%rbp), %rax
movq
%rax, %rdi
call
coolstrlen
leal
(%rbx,%rax), %eax
addl
$1, %eax
movl
%eax, -20(%rbp)
movl
-20(%rbp), %eax
cltq
movl
$1, %esi
movq
%rax, %rdi
call
calloc
movq
%rax, -32(%rbp)
movl
$.LC0, %edx
movl
-20(%rbp), %eax
movslq
%eax, %rbx
movq
-48(%rbp), %rsi
movq
-40(%rbp), %rcx
movq
-32(%rbp), %rax
movq
%rsi, %r8
movq
%rbx, %rsi
movq
%rax, %rdi
movl
$0, %eax
call
snprintf
movq
-32(%rbp), %rax
.L11:
addq
$40, %rsp
popq
%rbx
leave
.cfi_def_cfa 7, 8
.cfi_endproc
.LFE2:
.size
coolstrcat, .-coolstrcat
.section
.rodata
.LC1:
.string
.text
.globl coolgetstr
.type
coolgetstr, @function
coolgetstr:
.LFB3:
.cfi_startproc
pushq
%rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq
%rsp, %rbp
.cfi_def_cfa_register 6
subq
$32, %rsp
movl
$1, %esi
movl
$40960, %edi
call
calloc
movq
%rax, -16(%rbp)
movl
$0, -4(%rbp)
.L20:
movq
stdin(%rip), %rax
movq
%rax, %rdi
call
fgetc
movl
%eax, -20(%rbp)
cmpl
$-1, -20(%rbp)
.L14
cmpl
$10, -20(%rbp)
.L15
.L14:
cmpl
$0, -4(%rbp)
.L16
movl
$.LC1, %eax
.L17
.L16:
movq
-16(%rbp), %rax
.L17
.L15:
cmpl
$0, -20(%rbp)
.L18
movl
$1, -4(%rbp)
.L20
.L18:
movq
-16(%rbp), %rax
movq
%rax, %rdi
call
coolstrlen
%eax, %eax
addq
-16(%rbp), %rax
movl
-20(%rbp), %edx
movb
%dl, (%rax)
.L20
.L17:
leave
.cfi_def_cfa 7, 8
.cfi_endproc
.LFE3:
.size
coolgetstr, .-coolgetstr
.globl coolsubstr
.type
coolsubstr, @function
coolsubstr:
.LFB4:
.cfi_startproc
pushq
%rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq
%rsp, %rbp
.cfi_def_cfa_register 6
subq
$48, %rsp
movq
%rdi, -24(%rbp)
movq
%rsi, -32(%rbp)
movq
%rdx, -40(%rbp)
movq
-24(%rbp), %rax
movq
%rax, %rdi
call
coolstrlen
movl
%eax, -4(%rbp)
cmpq
$0, -32(%rbp)
.L22
cmpq
$0, -40(%rbp)
.L22
movq
-40(%rbp), %rax
movq
-32(%rbp), %rdx
addq
%rax, %rdx
movl
-4(%rbp), %eax
cltq
cmpq
%rax, %rdx
.L23
.L22:
movl
$0, %eax
.L24
.L23:
movq
-40(%rbp), %rdx
movq
-32(%rbp), %rax
addq
-24(%rbp), %rax
movq
%rdx, %rsi
movq
%rax, %rdi
call
strndup
.L24:
leave
.cfi_def_cfa 7, 8
.cfi_endproc
.LFE4:
.size
coolsubstr, .-coolsubstr
exit
%s.main
Main..new
start
program begins here
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bool..vtable
false
Bool..vtable
true
lt_end
lt_false
lt_true
lt_true
lt_string
two Strings
lt_false
lt_true
lt_int
two Ints
lt_bool
two Bools
lt_end
lt_true
less than
lt_end
lt_false
not less than
for non-primitives, < is always false
lt_string
lt_int
lt_bool
place the sum of the type tags in %s
lt_false
lt_false
lt_handler
helper function for <
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
le_end
le_false
le_true
le_true
le_string
two Strings
le_false
le_true
le_int
two Ints
le_bool
two Bools
le_end
le_true
less-than-or-equal
le_end
le_false
not less-than-or-equal
le_true
for non-primitives, equality is our only hope
le_string
le_int
le_bool
place the sum of the type tags in %s
le_false
le_false
le_true
le_handler
helper function for <=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
eq_end
eq_false
eq_true
eq_true
eq_string
two Strings
eq_false
eq_true
eq_int
two Ints
eq_bool
two Bools
eq_end
eq_true
equal
eq_end
eq_false
not equal
eq_true
otherwise, use pointer comparison
eq_string
eq_int
eq_bool
place the sum of the type tags in %s
eq_false
eq_false
eq_true
eq_handler
helper function for =
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
percent.ld
 %ld
percent.d
the.empty.string
global string constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Main
String
Bool
int_%ld
int%ld
String..vtable
Int..vtable
initialize attributes
%s..vtable
store class tag, object size and vtable pointer
stack room for temporaries: %ld
(raw content)
String
(raw content)
String
Bool
constructor for %s
%s..new
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%s.end
cgen.ml
%s.%d
division is OK
exit
IO.out_string
ERROR: %d: Exception: division by zero\n
cgen: aie eq/lt/le
lt_handler
le_handler
eq_handler
look up %s() at offset %ld in vtable
obtain vtable from object in %s with static type %s
SELF_TYPE
%s..vtable
obtain vtable for class %s
exit
IO.out_string
ERROR: %d: Exception: dispatch on void\n
look up %s() at offset %ld in vtable
obtain vtable for self object of type %s
end of if conditional
true branch
false branch
end of while loop
while conditional check
Bool
Bool
the.empty.string
String
String
String
Bool
fp[%ld] holds local %s (%s)
case expression ends
case expression: branches
exit
IO.out_string
ERROR: %d: Exception: case on void\n
case expression: void case
exit
IO.out_string
ERROR: %d: Exception: case without matching branch\n
case expression: error case
case expression: compare type tags
case expression begins
look up constructor at offset 1 in vtable
obtain vtable for self object
%s..new
SELF_TYPE
end of isvoid
true branch of isvoid
false branch of isvoid
Bool
self
%s holds "%s"
String
String
IO.in_int
IO.in_string
String
String
IO.out_int
IO.out_string
exit
IO.out_string
abort\n
done with Object.copy loop
look up type name at offset 0 in vtable
obtain vtable for self object
String
String
String.concat
String
String
String.length
exit
IO.out_string
ERROR: %d: Exception: String.substr out of range\n
String.substr
String
String
unknown Internal expression %s
String.substr
String.length
String.concat
Object.type_name
Object.copy
Object.abort
IO.out_string
IO.out_int
IO.in_string
IO.in_int
Bool
Bool
true
Bool
Bool
false
%s not found in frame
%s..new
virtual function table for %s
%s..vtable
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
string%d
method body ends
%s.%s.end
method body begins
stack room for temporaries: %ld
nope
_post
_pre
method definition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%s.%s
self[%ld] %s initializer -- none 
self[%ld] %s initializer <- %s
Bool
Bool
Bool
String
String
the.empty.string
String
String
Bool
self[%ld] holds field %s (%s)
%s.%d
%s.%d
Bool
%s.%d
Int..new
division is OK
exit
IO.out_string
ERROR: %d: Exception: division by zero\n
lt_handler
le_handler
eq_handler
Int..new
Bool..new
Bool..new
look up constructor at offset 1 in vtable
obtain vtable for self object
%s..new
SELF_TYPE
Bool..new
end of isvoid
true branch of isvoid
false branch of isvoid
look up %s() at offset %ld in vtable
obtain vtable from object in %s (type %s)
obtain %s for class %s (RCA)
SELF_TYPE
obtain %s for class %s (RCA)
exit
IO.out_string
ERROR: %d: Exception: dispatch on void\n
IO.out_int
out_int
SELF_TYPE
IO.out_string
out_string
SELF_TYPE
out_string
out_int
self
should not happen
Bool..new
Int..new
Int..new
the.empty.string
String..new
String
Bool
true
false
fp[%ld] holds case %s (%s)
case %s will jump to %s
Main
main
%s.%s
fp[%ld] holds %s (%d uses)
untyped
%s holds %s (%d uses)
untyped
fp[%ld] holds argument %s (%s)
self[%ld] holds field %s (%s)
no cfg
no cfg
%s.%s
%s.%s
Object
tac: parse error: 
string
isvoid
default
call
bool
return
label
comment
self
tac: addition not applied to two integers: 
 <- 
tac: subtraction not applied to two integers
tac: multiplication not applied to two integers
tac: division not applied to two integers
tac: negation not applied to integer
String
Bool
String
Bool
tac: unhandled call: 
 %Ld
tac: out_int called on non-integer
self
tac: out_string called on non-string
self
out_string
out_int
in_string
in_int
THREE-ADDRESS CODE STEPS: %d
tac: label not found: 
tac: variable not found: 
Bool.new
String..new
Int..new
Bool..new
String..new
Int..new
CYCLES: %Ld
system calls
divisions
multiplications
branch mispredictions
branch predictions
cache misses
cache hits
pushes and pops
instructions
PC = %5ld, time = %ld
PC %ld points to memory that has never been assigned to
PC %ld points to constant %ld, not an instruction
PC %ld points to constant label %s, not an instruction
PC %ld points to constant string "%s", not an instruction
label start not found
start
label expected in %s, integer %ld found instead%s
label expected in %s, string "%s" found instead%s
label expected in %s, code segment instruction from line %d found instead
integer expected in %s, string "%s" found instead%s
integer expected in %s, code segment instruction from line %d found instead
integer expected in %s %s, label %s found instead%s
integer expected in %s %s, string "%s" found instead%s
integer expected in %s %s, code segment instruction from line %d found instead
attempt to read from register %s that has never been assigned to
string expected, int %ld found instead%s
string expected, label %s found instead%s
string expected, code segment instruction from line %d found instead
attempt to read from memory address %ld that has never been written to
"%s"
<code from ASM line %d>
 (last set at time %ld by instr at line %d)
PROFILE: %22s = %10Ld @ %4Ld => %10Ld
cannot compare %s=%s with %s=%s
register %s holds %s which is not the address of a defined label for call
label %s is not the address of a defined label for call
(push)
(pop)
DEBUG: %d: at time %ld, %s = %s%s
(sub)
(sub)
(mul)
(mul)
division by zero: %s <- %ld / %ld
(div)
(div)
attempt to allocate %ld
(alloc)
 %Ld
(IO.out_int)
unknown system call %s
exit
String.substr
String.length
String.concat
IO.out_string
IO.out_int
IO.in_string
IO.in_int
(return)
(points to %s%s)
%s = %s%s
stack overflow
Call to %s from line %d
address expected in %s, undefined label %s found instead%s
address expected in %s, string value "%s" found instead
address expected in %s, code segment instruction from line %d found instead
reference to undefined label %s
label %s multiply defined
__main__
main
Main
cannot find %d in store
cannot find %s in environment
String
Bool
String
Bool
stack overflow
%s(...)
Int(%ld)
Bool(%b)
String(%s)
Void
parameter count mismatch
dispatch on void
parameter count mismatch
static dispatch on void
got %s for if conditional
got %s for while conditional
__while_void__
__block_void__
case on void
STRING
BOOL
attribute count mismatch
SELF_TYPE
%s + %s
%s - %s
%s * %s
%s / %s
division by zero
got %s for integer negation
got %s for boolean not
self
 %Ld
IO.out_int on %s
IO.out_string on %s
abort
Object
String.concat on %s
String.concat(%s)
String.length on %s
String.substr on %s
String.length(%s,%s)
String.substr out of range
unknown internal method %s
String.substr
String.length
String.concat
Object.type_name
Object.copy
Object.abort
IO.out_string
IO.out_int
IO.in_string
IO.in_int
 env:
eval: %s
Object
Object
 %s=%s
case without matching branch: %s
Tc.Found
Bool
String
concat
String
String
String
String.concat
length
String.length
substr
String
String
String.substr
in_int
IO.in_int
in_string
String
String
IO.in_string
out_int
SELF_TYPE
SELF_TYPE
IO.out_int
out_string
String
SELF_TYPE
SELF_TYPE
IO.out_string
Object
abort
Object
Object
Object.abort
copy
SELF_TYPE
SELF_TYPE
Object.copy
type_name
String
String
Object.type_name
class Main method main not found
class Main method main with 0 parameters not found
Main
main
class Main not found
Main
inheritance cycle: %s
unknown class %s in dispatch
unknown method %s in dispatch on %s
unbound identifier %s
Internal error processing Class Map; please report to course staff.
cool
class-map
Internal error processing Imp Map; please report to course staff.
im_prime
im_normal
cool
imp-map
number of methods in the implementation map entry
class name
number of classes
implementation_map expected (got %s)
implementation_map
implementation_map
implementation_map
dispatch on unknown class %s
dispatch on unknown method %s of class %s
number of attributes in the class map entry
class name
number of classes
class_map expected (got %s)
class_map
class_map
class_map
parent name
child class name
number of classes
parent_map expected (got %s)
parent_map
parent_map
parent_map
class %s not found
SELF_TYPE
SELF_TYPE(%s)
SELF_TYPE
class %s redefines method %s and changes number of formals
class %s redefines method %s and changes return type (from %s to %s)
class %s redefines attribute %s
class %s has attribute %s with unknown type %s
SELF_TYPE
class %s has an attribute named self
self
class %s has method %s with unknown return type %s
SELF_TYPE
class %s redefines method %s
Object
Object
class %s inherits from Bool
class %s inherits from Int
class %s inherits from String
class %s inherits from unknown class %s
String
Bool
class named SELF_TYPE
SELF_TYPE
class %s redefined
Bool
comparison between %s and %s
String
Bool
String
Bool
arithmetic on %s %s instead of Ints
wrong number of actual arguments (%d vs. %d)
internal error on dynamic dispatch
cannot assign to self
%s does not conform to %s in assignment
self
wrong number of actual arguments (%d vs. %d)
%s does not conform to %s in static dispatch
conditional has type %s instead of Bool
Bool
Object
predicate has type %s instead of Bool
Bool
empty blocks are not allowed
Object
initializer type %s does not conform to type %s
binding self in a let is not allowed
self
unknown type %s
Object
SELF_TYPE
empty case expressions are not allowed
unknown type %s
Object
SELF_TYPE
Bool
negate applied to type %s instead of Int
not applied to type %s instead of Bool
Bool
self
String
internal function %s used directly
Bool
(parent) class defining this method
number of formals
method name
type name
attribute name
type name
attribute name
no_initializer or initializer expected (got %s)
no_initializer
initializer
class map attribute kind
class %s redefines method %s and changes type of formal %s
class %s has method %s with formal parameter of unknown type %s
class %s has method %s with formal parameter named self
self
class %s has method %s with duplicate formal parameter named %s
%s does not conform to %s in initialized attribute
SELF_TYPE
self
%s does not conform to %s in method %s
self
SELF_TYPE
argument #%d type %s does not conform to formal type %s
argument #%d type %s does not conform to formal type %s
binding self in a case expression is not allowed
self
case branch type %s is bound twice
using SELF_TYPE as a case branch type is not allowed
Object
unknown type %s
Object
SELF_TYPE
cannot find lub of %s and %s
formal name
no_initializer
initializer
formal %s has type SELF_TYPE
SELF_TYPE
Internal error processing AST; please report to course staff.
cool
assign
dynamic_dispatch
static_dispatch
self_dispatch
while
block
case
isvoid
plus
minus
times
divide
negate
identifier
integer
string
internal
true
false
ERROR: %d: Internal Error: expression %s has no internal type
type/identifier
type/identifier line number
number of classes
number of features
number of expressions
number of formals
number of cases
internal kind
number of let bindings
string constant
expected an expression kind (got %S)
while
true
times
string
static_dispatch
self_dispatch
plus
negate
minus
isvoid
internal
integer
identifier
false
dynamic_dispatch
divide
case
block
assign
expression kind
expression type
expression line number
expected integer constant
expected integer constant (got %S)
integer constant
expected %s
expected %s (got %S)
expected %s
no_inherits
inherits
attribute_no_init
attribute_init
method
let_binding_no_init
let_binding_init
expected inherits or no_inherits (got %s)
no_inherits
inherits
class inheritance
expected attribute_no_init or attribute_init or method(got %s)
method
attribute_no_init
attribute_init
kind of feature
expected let_binding_no_init or let_binding_init (got %s)
let_binding_no_init
let_binding_init
kind of let binding
inherits 
class
) : 
else 
then 
pool 
loop 
while 
let 
 esac 
case 
new 
isvoid 
not 
%ld 
"%s" 
internal %s
true 
false 
case
class
else
esac
false
inherits
isvoid
loop
pool
"%s"
then
true
while
(* end of file *)
Internal error processing tokens; please report to course staff.
%d %d
cool
tokens
Unknown token type %S
while
type
true
times
tilde
then
string
semi
rparen
rbrace
rarrow
pool
plus
minus
lparen
loop
lbrace
larrow
isvoid
integer
inherits
identifier
false
esac
equals
else
divide
comma
colon
class
case
case
class
colon
comma
divide
else
equals
esac
false
identifier
inherits
integer
isvoid
larrow
lbrace
loop
lparen
minus
plus
pool
rarrow
rbrace
rparen
semi
string
then
tilde
times
true
type
while
string constant is too long (%d > 1024)
not a 32-bit signed integer: %s
not a 32-bit signed integer: %s
invalid character: %s
EOF in (* comment *)
TOK_COLON
TOK_LARROW
TOK_LBRACKET
TOK_RBRACKET
TOK_IDENTIFIER
TOK_STRING
TOK_INTEGER
TOK_REG
TOK_OP_MOV
TOK_OP_CALL
TOK_OP_RETURN
TOK_OP_BZ
TOK_OP_JMP
TOK_OP_BNZ
TOK_OP_BLT
TOK_OP_BLE
TOK_OP_BEQ
TOK_OP_PUSH
TOK_OP_POP
TOK_OP_DEBUG
TOK_OP_SYSCALL
TOK_OP_TRACE
TOK_OP_ADD
TOK_OP_SUB
TOK_OP_MUL
TOK_OP_DIV
TOK_OP_LI
TOK_OP_LA
TOK_OP_LD
TOK_OP_ST
TOK_REG_SP
TOK_REG_FP
TOK_REG_RA
TOK_CONSTANT
TOK_OP_ALLOC
TOK_EOF
parser
## return address handling
## FIXME: %s
movq %s, %s
call *%s
call %s
jmp %s
cmpq $0, %s
je %s
cmpq $0, %s
jne %s
cmpl %s, %s
jl %s
cmpl %s, %s
jle %s
cmpq %s, %s
je %s
pushq %s
popq %s
movq %s, %%rax
addq %s, %%rax
movq %%rax, %s
addq %s, %s
addq %s, %s
movq %s, %%rax
subq %s, %%rax
movq %%rax, %s
subq %s, %s
movq %s, %%rax
imull %s, %%eax
shlq $32, %%rax
shrq $32, %%rax
movl %%eax, %s
movq $0, %%rdx
movq %s, %%rax
cdq 
idivl %s
movq %%rax, %s
movq $%ld, %s
movq $%s, %s
movq %ld(%s), %s
movq %s, %ld(%s)
.quad %ld
.quad %s
.byte 0
.byte %3d # %C
# %S
## %s
movq $8, %%rsi
movq %s, %%rdi
call calloc
movq %%rax, %s
movl
$1, %%esi
movl $4096, %%edi
call calloc
pushq %%rax
movq %%rax, %%rdi
movq $4096, %%rsi 
movq stdin(%%rip), %%rdx
call fgets 
popq %%rdi 
movl $0, %%eax
pushq %%rax
movq %%rsp, %%rdx
movq $percent.ld, %%rsi
call sscanf
popq %%rax
movq $0, %%rsi 
cmpq $2147483647, %%rax 
cmovg %%rsi, %%rax
cmpq $-2147483648, %%rax 
cmovl %%rsi, %%rax
movq %%rax, %s
call coolgetstr 
movq %%rax, %s
movq $percent.d, %%rdi
movl %s, %%eax
cdqe
movq %%rax, %%rsi
movl $0, %%eax
call printf
movq %s, %%rdi
call cooloutstr
movq %s, %%rdi
movq %s, %%rsi
call coolstrcat
movq %%rax, %s
movq %s, %%rdi
movl $0, %%eax
call coolstrlen
movq %%rax, %s
movq %s, %%rdi
movq %s, %%rsi
movq %s, %%rdx
call coolsubstr
movq %%rax, %s
movl $0, %edi
call exit
exit
String.substr
String.length
String.concat
IO.out_string
IO.out_int
IO.in_string
IO.in_int
addq $%ld, %s
  movq %s, %%rdi
  movq %s, %%rsi
  call strcmp 
  cmp $0, %%eax
  jl %s
  movq %s, %%rdi
  movq %s, %%rsi
  call strcmp 
  cmp $0, %%eax
  jle %s
  movq %s, %%rdi
  movq %s, %%rsi
  call strcmp 
  cmp $0, %%eax
  je %s
strcmp
.globl main
.type main, @function
main:
xreg_to_str: 
%r12d
%r13d
%r14d
%r15d
%r10d
%esp
%ebp
%ebx
xreg_to_str: 
%r12
%r13
%r14
%r15
%r10
%rsp
%rbp
%rbx
mov %s <- %s
call %s
call %s
jmp %s
bz %s %s
bnz %s %s
blt %s %s %s
ble %s %s %s
beq %s %s %s
push %s
pop %s
debug %s
add %s <- %s %s
sub %s <- %s %s
mul %s <- %s %s
div %s <- %s %s
li %s <- %ld
la %s <- %s
ld %s <- %s[%ld]
st %s[%ld] <- %s
constant %ld
constant %s
constant "%s"
;; %s
alloc %s %s
syscall %s
;; AddI in Cool Assembly
;; Strcmp in Cool Assembly
return
trace
;; execution begins here
%-24s%s
.globl %s
%-24s%s
%-24s%s
%-24s%s
string constant is too long (%d > 1024)
while
then
pool
loop
isvoid
inherits
esac
else
class
case
not a non-negative 32-bit signed integer: %s
not a non-negative 32-bit signed integer: %s
invalid character: %s
EOF in (* comment *)
TOK_AT
TOK_CASE
TOK_CLASS
TOK_COLON
TOK_COMMA
TOK_DIVIDE
TOK_DOT
TOK_ELSE
TOK_EQUALS
TOK_ESAC
TOK_FALSE
TOK_FI
TOK_IDENTIFIER
TOK_IF
TOK_IN
TOK_INHERITS
TOK_INTEGER
TOK_ISVOID
TOK_LARROW
TOK_LBRACE
TOK_LE
TOK_LET
TOK_LOOP
TOK_LPAREN
TOK_LT
TOK_MINUS
TOK_NEW
TOK_NOT
TOK_OF
TOK_PLUS
TOK_POOL
TOK_RARROW
TOK_RBRACE
TOK_RPAREN
TOK_SEMI
TOK_STRING
TOK_THEN
TOK_TILDE
TOK_TIMES
TOK_TRUE
TOK_TYPE
TOK_WHILE
TOK_EOF
parser
String
Object
Bool
Bool
String
Bool
_dead_
start
_dead_
DOT ERROR: %s: %s
  n%d [label=%S];
(Node %d)
  n%d [label=%S];
(Node %d)
digraph %s {
.dot
t$%d
%s + %s
%s - %s
%s * %s
%s / %s
~ %s
%s < %s
%s <= %s
%s = %s
not %s
new %s
isvoid %s
%s.%s(
%s@%s.%s(
-- %s
return
%s <- 
Default_%s
true
false
label %s_%d
comment %s
%s <- int %ld
%s <- string "%s"
%s <- not %s
%s <- default "%s"
%s <- bool true
%s <- bool false
cfg: binop
unimplemented
fcall-post to %s
fcall-pre to %s
fcall-post to %s
fcall-pre to %s
self
if-join
else branch
then branch
Object
while-body
while-join
while-pred
 n%d -> n%d [label=%S];
bt %s %s_%d
jmp %s_%d
%s <- + %s %s
%s <- - %s %s
%s <- * %s %s
%s <- / %s %s
%s <- ~ %s
%s <- < %s %s
%s <- <= %s %s
%s <- = %s %s
%s <- not %s
%s <- %s
%s <- int %ld
%s <- string
%s <- not %s
%s <- default %s
%s <- bool true
%s <- bool false
%s <- new %s
%s <- isvoid %s
%s <- call %s
comment %s
return %s
cfg: empty block
%s <- %s
%s.%s(...)
%s@%s.%s(...)
%s(...)
if %s then %s else %s
while %s loop %s pool
{ ... }
let ... in ...
case %s ...
new %s
isvoid %s
%s + %s
%s - %s
%s * %s
%s / %s
~ %s
%s < %s
%s <= %s
%s = %s
not %s
"%s"
internal %s
true
false
COOL_BUG
Best-Effort Backtrace:
ERROR: %d: Assembler: %s
ERROR: %d: Type-Check: %s
ERROR: %d: Exception: %s
ERROR: %d: Run-Time Type Error: %s
ERROR: %d: Simple Parser: %s
ERROR: %d: Parser: %s near %s
ERROR: %d: Lexer: %s
Str.matched_group
Str.group_end
Str.group_beginning
spurious \) in regular expression
str.ml
str.ml
\( group not closed by \)
[ class not closed by ]
too many \(...\) groups
too many r* or r+ where r is nullable
127.0.0.1
0.0.0.0
Unix.Unix_error
Unix.Unix_error
close_process_full
close_process
close_process_out
close_process_in
/bin/sh
/bin/sh
/bin/sh
/bin/sh
/bin/sh
/bin/sh
127.0.0.1
0.0.0.0
Unix.sendto
Unix.send
Unix.recvfrom
Unix.recv
Unix.single_write
Unix.write
Unix.read
 on "
" failed
Arg.Stop
Arg.Help
Arg.Bad
--help
 Display this list of options
--help
-help
 Display this list of options
-help
-help
  %s %s
  %s %s %s
<none>
a boolean
bool_of_string
an integer
int_of_string
an integer
int_of_string
a float
float_of_string
a float
float_of_string
one of: 
--help
-help
%s: unknown option `%s'.
-help
--help
%s: wrong argument `%s'; option `%s' expects %s.
%s: option `%s' needs an argument.
%s: %s.
Array.Bottom
Array.blit
Array.fill
Array.sub
array.ml
buffer.ml
Buffer.add_substring
Buffer.add: cannot grow buffer
Buffer.nth
Buffer.sub
Char.chr
%02x
Digest.substring
filename.ml
Win32
Unix
Cygwin
TEMP
'\''
/tmp
TMPDIR
%s%06x%s
Filename.chop_suffix
\\\"
Filename.chop_extension
Lexing.lex_refill: cannot grow buffer
list.ml
List.combine
List.exists2
List.for_all2
List.fold_right2
List.fold_left2
List.iter2
List.map2
List.nth
List.rev_map2
Map.remove_min_elt
Map.bal
Map.bal
Map.bal
Map.bal
Marshal.from_size
Marshal.from_string
Marshal.data_size
Marshal.to_buffer: substring out of bounds
Parsing.Parse_error
Parsing.YYexit
syntax error
Pervasives.do_at_exit
Pervasives.Exit
really_input
input
output
%.12g
bool_of_string
true
false
false
true
char_of_int
File "%s", line %d, characters %d-%d: %s
Uncaught exception: %s
Uncaught exception: %s
Assertion failed
Pattern matching failed
Stack overflow
Out of memory
(%s%s)
(%s)
, %s%s
printf: premature end of format string ``
printf: bad conversion %
, at char number 
 in format string ``
printf: bad positional specification (0).
printf.ml
Queue.Empty
$_>,
6O?k
Ee\$'
Random.int64
Random.int32
Random.int
Scanf.Scan_failure
stdin
input channel
function input
a boolean
a boolean
a boolean
a char
a char
bad char \%c%c%c
scanf.ml
scanf.ml
invalid boolean 
true
false
looking for one of range %S, found %C
looking for %C, found %C
format read %S does not match specification %S
no dot or exponent part found in float token
scanf: premature end of format string ``%s''
scanf: bad conversion %%%c, at char number %i in format string ``%s''
scanf: bad input at char number %i: %s
illegal escape character %C
string input
end of input not found
a string
a string
a string
a string
a char
a char
Set.remove_min_elt
Set.bal
Set.bal
Set.bal
Set.bal
String.rcontains_from
String.contains_from
String.rindex_from
String.index_from
String.blit
String.fill
String.sub
3.09.3
Sys.Break
index out of bounds
